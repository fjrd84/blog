# ReasonML Programming Language

These are some notes about the ReasonML programming language that I've taken while watching the (free) course [Get Started with Reason](https://egghead.io/courses/get-started-with-reason) of [Nik Graf](https://twitter.com/nikgraf).

## What is ReasonML?

ReasonML is an object-functional programming language created at Facebook. You can find more details on [What is ReasonML?](http://2ality.com/2017/11/about-reasonml.html).

## What I Like and Dislike so Far

I like:

- Inferred types
- The possibility of creating custom types and variants
- The compiler warns you if your switches are not exhaustive (if you're forgetting cases)
- Code suggestions underneath the command line are cool
- Compatibility with JS and OCaml
- Lexical scoping
- `If` is an expression that can be evaluated into a value (in other languages it is only an statement)
- Syntax of switch expressions
- Objects (or records) defined in a similar way as in TypeScript
- How to destructure objects in a similar way as in Javascript
- Spread operator as in Javascript
- Combinations of variants with switch expressions are great
- You can match specific cases in a switch
- There's no null: variants None and Some can be used instead
- You can partially apply arguments in functions (automatic currying)
- Labeled parameters (you can apply then in any order you want)
- Optional parameters
- Pipe operator for function composition
- Nested structures can directly be compared for equality
- Structural `==` and referential equality `===` operators
- Powerful pattern matching

I dislike:

- Shadowing is allowed (let variables can be redefined)
- Operator ++ for concatenating strings
- Underscores in the built-in functions' names
- Too many semicolons

## Code Examples

```reason

let foo = {
  let a = 40;
  let b = 1;
  a + b + 1;
}; // this will bind 42 to the name `foo`

let isMorning = true;
// This binds "Good Morning" to the name `greeting`
let greeting = if (isMorning) {"Good Morning"} else {"Hello"};

// A switch expression
let greeting = stranger =>
  switch (stranger) {
    | Teacher => "Hey professor"
    | Director => "Hello director"
    | Student("Richard") => "Still here Ricky?"
    | Student(anyOtherName) => "Hey, " ++ anyOtherName ++ "."
    | _ => "unknown"
  };

// A person type definition
type person = {
  name: string,
  age: int,
  mutable mood: string, // mood is the only mutable field in this type
};

// A record of type person
let tim = {
  name: "Tim",
  age: 52,
  mood: "happy"
};

// Destructuring a person type into variables timsAge and timsName
let {age: timsAge, name: timsName} = tim;

// Custom type answer (tagged union or variant)
type answer =
  | Yes
  | No
  | Maybe;

// Further assignments automatically infer the type
let isItRaining = Maybe; // It infers type `answer`

// You can define functions like this (in this case, types are optional, since they
// can be inferred
let add: (x: int, y: int) : int => x + y;

// A function with labelled and optional parameters
let name = (~firstName="Defaultname", ~middleName=?, ~lastName, ()) => {
  switch (middleName) {
  | Some(value) => firstName ++ " " ++ value ++ " " ++ lastName
  | None => firstName ++ " " ++ lastName
  };
};

// Pipe operators example: find the largest element smaller than 4
[8, 3, 6, 1]
  |> List.sort(compare)
  |> List.rev
  |> List.find(x => x < 4);

// Recursive functions (without rec, the function cannot call itself)
let rec countBack = x => {
  if (x > 1) {
    print_int(x);
    countBack(x - 1);
  };
};

// There are tuples too (unlike lists, they can contain elements of different types)
("this is", 1, "tuple", "of four elements")

// And there are arrays. Unlike lists, they're mutable
[|3, 4|]

// A pattern matching example
switch ([|"a", "b", "c"|]) {
| [|"a", "b", _|] => print_endline("a, b and something")
| [|_, x, y|] => print_endline("something and " ++ x ++ " " ++ y)
| _ => print_endline("An Array")
};

```
